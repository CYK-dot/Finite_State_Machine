# FSM有限状态机
## 简介
为RCS电控软件组编写的一个简单的有限状态机框架，基于C语言实现。
## 实现的基本功能
1. **主要功能**
- 支持状态机的三个核心概念：状态函数(state)、事件(Event)、行为(Action)。
- 支持状态机的两个工作内容：事件触发状态转移、事件触发行为。
2. **初始化方式**
- 状态机在使用前需要经过初始化，避免野指针的出现。
- 状态和事件需要通过相关函数来进行注册，无法使用未经注册的状态和行为。
- 注册时会为每个状态、行为自动分配ID，ID不对外暴露。注册后仅需使用函数名即可直接指代对应的状态和行为。
- 事件及其ID需要手动在.h文件中通过define的方式指定。
- 通过明确的函数接口配置状态转移表和行为触发表，配置时直接使用函数名和事件ID，便于理解。
- 需要手动指定状态机的初始状态和初始事件。
3. **使用方式**
- 进行初始化后，仅调用状态机内核FSM_Main即可运行状态机，FSM_Main会自动选择此时需要执行的状态函数。
## 实现的附加功能
1. **状态机上下文变量**
- 可以将一个任意类型的变量注册为状态机的上下文变量(一般被定义为结构体类型)，在各个函数间相互共用。
- 要求状态函数、行为函数必须被定义为void(void*)，以接收状态机内核传入的上下文变量。
- 上下文变量可以应对不便于拆成多个状态的时序逻辑，简化代码。
2. **钩子函数与调试支持**
- 为内核相关的函数提供钩子，能够挂入用户代码。
- 提供诺干便于调试的函数，以观察状态机内核的运行状态。
- 通过取消FSM_ENABLE_RECORDER的注释，会将日志记录函数挂入状态机内核，此时可以用FSM_Get_Recorder访问日志输出
- 也可以通过调用FSM_Hook_On_FSM_Main，挂入自己编写的函数，记录所需的内容。

## 状态机内核的运行逻辑
1. **状态的跳转与动作的触发**
- 为“无事发生”分配了一个事件ID，为“没有动作”分配了一个空的函数Action_Skip。
- FSM_Main被调用后，首先会判断当前事件类型，如果是无事发生，则状态机调用函数指针，继续执行状态函数。
- 如果当前事件如果并非“无事发生”，则先根据当前状态和当前事件，检索两张二维数组，获取要执行的动作和将要转移到的状态。
- 检索完成后，状态机先执行动作函数，然后修改状态，最后将事件复位为“无事发生”。FSM_Main下一次被触发时，就会调用转移过后的状态函数了。
1. **状态的注册**
- FSM_Add_State将状态函数的函数指针送入数组中，然后数组的队头+1。
- 而该函数指针在数组中的位置便被称为状态ID，朴素直观。
2. **状态转移的注册**
- 状态转移表存放的只能是ID，而做不到存放函数指针。但我们在编写代码时不希望关注状态的ID，而只希望关心状态函数的名称。
- 因此FSM_Add_Event_State会先遍历函数指针的数组，找到相同的函数指针，然后获取他在数组中的位置，通过这种方式获取状态的ID。
- 最后将输入的事件、起始状态的ID、目标状态的ID送入二维数组，FSM_Add_Event_State便完成了某个状态转移的注册。
